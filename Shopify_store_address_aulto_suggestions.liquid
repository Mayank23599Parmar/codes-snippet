<style>/* Address Autocomplete Styles */

.address-autocomplete-section {
  padding: 40px 20px;
  max-width: 800px;
  margin: 0 auto;
}

.address-autocomplete-container {
  background: #fff;
  border-radius: 8px;
  padding: 30px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.address-autocomplete-title {
  font-size: 28px;
  font-weight: 600;
  margin-bottom: 10px;
  color: #333;
}

.address-autocomplete-description {
  font-size: 16px;
  color: #666;
  margin-bottom: 30px;
  line-height: 1.5;
}

.address-autocomplete-wrapper {
  position: relative;
  margin-bottom: 20px;
}

.address-autocomplete-label {
  display: block;
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 8px;
  color: #333;
}

.address-autocomplete-input {
  width: 100%;
  padding: 12px 16px;
  font-size: 16px;
  border: 2px solid #ddd;
  border-radius: 6px;
  outline: none;
  transition: border-color 0.3s ease;
  box-sizing: border-box;
}

.address-autocomplete-input:focus {
  border-color: #0066cc;
  box-shadow: 0 0 0 3px rgba(0, 102, 204, 0.1);
}

.address-autocomplete-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #fff;
  border: 1px solid #ddd;
  border-top: none;
  border-radius: 0 0 6px 6px;
  max-height: 300px;
  overflow-y: auto;
  z-index: 1000;
  display: none;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.address-autocomplete-suggestions.active {
  display: block;
}

.address-autocomplete-suggestion {
  padding: 12px 16px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
  transition: background-color 0.2s ease;
  font-size: 14px;
  line-height: 1.5;
  color: #333;
}

.address-autocomplete-suggestion:last-child {
  border-bottom: none;
}

.address-autocomplete-suggestion:hover {
  background-color: #f5f5f5;
}

.address-autocomplete-suggestion strong {
  font-weight: 600;
  color: #0066cc;
}

.address-autocomplete-loading,
.address-autocomplete-error {
  padding: 12px 16px;
  text-align: center;
  color: #666;
  font-size: 14px;
}

.address-autocomplete-error {
  color: #d32f2f;
}

.address-autocomplete-selected {
  margin-top: 30px;
  padding: 20px;
  background: #f9f9f9;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
}

.address-autocomplete-selected h3 {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 15px;
  color: #333;
}

.selected-address-details p {
  margin: 8px 0;
  font-size: 14px;
  color: #666;
  line-height: 1.5;
}

.selected-address-details p:first-child {
  font-weight: 500;
  color: #333;
  font-size: 16px;
}

.address-loading {
  padding: 15px;
  text-align: center;
  color: #666;
  font-style: italic;
}

.address-prediction-info {
  margin-bottom: 20px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e0e0e0;
}

.address-full-details {
  margin-top: 20px;
}

.address-full-details h4 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 15px;
  color: #333;
}

.address-fields {
  display: grid;
  gap: 12px;
}

.address-fields p {
  margin: 0;
  padding: 10px;
  background: #fff;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
  font-size: 14px;
  line-height: 1.6;
}

.address-fields p strong {
  display: inline-block;
  min-width: 140px;
  color: #333;
  font-weight: 600;
}

.address-fields span {
  color: #666;
}

.address-error {
  color: #d32f2f;
  padding: 10px;
  background: #ffebee;
  border-radius: 4px;
  border: 1px solid #ffcdd2;
}

.address-validation {
  margin-top: 20px;
  padding: 20px;
  background: #f5f5f5;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
}

.address-validation h4 {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 15px;
  color: #333;
}

.validation-status {
  margin-bottom: 15px;
}

.validation-success {
  padding: 15px;
  background: #e8f5e9;
  border-radius: 4px;
  border: 1px solid #c8e6c9;
  color: #2e7d32;
}

.validation-success strong {
  display: block;
  margin-bottom: 5px;
  font-size: 16px;
}

.validation-warning {
  padding: 15px;
  background: #fff3e0;
  border-radius: 4px;
  border: 1px solid #ffcc80;
  color: #e65100;
}

.validation-warning strong {
  display: block;
  margin-bottom: 5px;
  font-size: 16px;
}

.validation-info {
  margin-top: 10px;
  padding-top: 10px;
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  font-size: 13px;
}

.validation-info p {
  margin: 5px 0;
  color: #666;
}

.validation-concerns h5,
.validation-suggestions h5 {
  font-size: 14px;
  font-weight: 600;
  margin: 15px 0 10px 0;
  color: #333;
}

.concern-item,
.suggestion-item {
  margin: 10px 0;
  padding: 12px;
  background: #fff;
  border-radius: 4px;
  border: 1px solid #e0e0e0;
  font-size: 13px;
}

.concern-item p,
.suggestion-item p {
  margin: 5px 0;
  line-height: 1.5;
}

.concern-item strong,
.suggestion-item strong {
  color: #333;
  min-width: 100px;
  display: inline-block;
}

/* Scrollbar styling for suggestions */
.address-autocomplete-suggestions::-webkit-scrollbar {
  width: 8px;
}

.address-autocomplete-suggestions::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.address-autocomplete-suggestions::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

.address-autocomplete-suggestions::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Responsive styles */
@media (max-width: 768px) {
  .address-autocomplete-section {
    padding: 20px 15px;
  }

  .address-autocomplete-container {
    padding: 20px;
  }

  .address-autocomplete-title {
    font-size: 24px;
  }

  .address-autocomplete-description {
    font-size: 14px;
  }
}



</style>

<div class="address-autocomplete-section">
  <div class="address-autocomplete-container">
    <h2 class="address-autocomplete-title">Enter Your Address</h2>
    <p class="address-autocomplete-description">Start typing your address and select from the suggestions</p>
    
    <div class="address-autocomplete-wrapper">
      <label for="address-input" class="address-autocomplete-label">
        Address
      </label>
      <input
        type="text"
        id="address-input"
        class="address-autocomplete-input"
        placeholder="Start typing your address..."
        autocomplete="off"
      />
      <div class="address-autocomplete-suggestions" id="address-suggestions"></div>
    </div>

    <div class="address-autocomplete-selected" id="selected-address" style="display: none;">
      <h3>Selected Address:</h3>
      <div class="selected-address-details" id="address-details-container">
        <div class="address-loading" style="display: none;">
          <p>Loading address details...</p>
        </div>
        <div class="address-prediction-info">
          <p class="selected-address-description"></p>
          <p class="selected-address-id"></p>
          <p class="selected-address-service"></p>
        </div>
        <div class="address-full-details" style="display: none;">
          <h4>Full Address Details:</h4>
          <div class="address-fields">
            <p><strong>Address Line 1:</strong> <span class="address-field-address1"></span></p>
            <p><strong>Address Line 2:</strong> <span class="address-field-address2"></span></p>
            <p><strong>City:</strong> <span class="address-field-city"></span></p>
            <p><strong>Province/State:</strong> <span class="address-field-province"></span></p>
            <p><strong>Province Code:</strong> <span class="address-field-province-code"></span></p>
            <p><strong>ZIP/Postal Code:</strong> <span class="address-field-zip"></span></p>
            <p><strong>Country:</strong> <span class="address-field-country"></span></p>
            <p><strong>Country Code:</strong> <span class="address-field-country-code"></span></p>
            <p><strong>Latitude:</strong> <span class="address-field-latitude"></span></p>
            <p><strong>Longitude:</strong> <span class="address-field-longitude"></span></p>
          </div>
        </div>
        <div class="address-validation" style="display: none;">
          <h4>Address Validation:</h4>
          <div class="validation-status" id="validation-status"></div>
          <div class="validation-concerns" id="validation-concerns" style="display: none;"></div>
          <div class="validation-suggestions" id="validation-suggestions" style="display: none;"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script >
  /**
 * Address Autocomplete using Shopify Atlas GraphQL API
 */

class AddressAutocomplete {
  constructor(inputElement, suggestionsContainer, options = {}) {
    this.input = inputElement;
    this.suggestionsContainer = suggestionsContainer;
    this.options = {
      countryCode: options.countryCode || 'IN',
      locale: options.locale || 'en-IN',
      location: options.location || { longitude: 72.5871, latitude: 23.0276 },
      debounceDelay: options.debounceDelay || 300,
      ...options
    };
    
    this.sessionToken = this.generateSessionToken();
    this.debounceTimer = null;
    this.selectedAddress = null;
    
    this.init();
  }

  generateSessionToken() {
    // Generate a unique session token for each session
    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  init() {
    // Add event listeners
    this.input.addEventListener('input', (e) => this.handleInput(e));
    this.input.addEventListener('focus', () => this.handleFocus());
    this.input.addEventListener('blur', () => {
      // Delay to allow click events on suggestions
      setTimeout(() => this.handleBlur(), 200);
    });

    // Create suggestions container if it doesn't exist
    if (!this.suggestionsContainer) {
      this.suggestionsContainer = document.createElement('div');
      this.suggestionsContainer.className = 'address-autocomplete-suggestions';
      this.input.parentNode.appendChild(this.suggestionsContainer);
    }
  }

  handleInput(e) {
    const query = e.target.value.trim();
    
    // Clear previous timer
    clearTimeout(this.debounceTimer);
    
    // Hide suggestions if input is empty
    if (query.length === 0) {
      this.hideSuggestions();
      return;
    }

    // Debounce the API call
    this.debounceTimer = setTimeout(() => {
      this.fetchSuggestions(query);
    }, this.options.debounceDelay);
  }

  handleFocus() {
    // Show suggestions if input has value
    if (this.input.value.trim().length > 0) {
      const query = this.input.value.trim();
      this.fetchSuggestions(query);
    }
  }

  handleBlur() {
    // Hide suggestions when input loses focus
    this.hideSuggestions();
  }

  async fetchSuggestions(query) {
    if (!query || query.length < 2) {
      this.hideSuggestions();
      return;
    }

    try {
      // Show loading state
      this.showLoading();

      const queryPayload = {
        operationName: "predictions",
        query: `
          query predictions($query: String, $countryCode: AutocompleteSupportedCountry!, $locale: String!, $location: LocationInput, $sessionToken: String!, $adapterOverride: String) {
            predictions(query: $query, countryCode: $countryCode, locale: $locale, location: $location, sessionToken: $sessionToken, adapterOverride: $adapterOverride) {
              addressId
              description
              completionService
              matchedSubstrings {
                length
                offset
              }
            }
          }
        `,
        variables: {
          query: query,
          countryCode: this.options.countryCode,
          location: this.options.location,
          locale: this.options.locale,
          sessionToken: this.sessionToken
        }
      };

      const response = await fetch('https://atlas.shopifysvc.com/graphql', {
        method: 'POST',
        body: JSON.stringify(queryPayload),
        headers: {
          'content-type': 'application/json',
        },
      });

      const data = await response.json();

      if (data.errors) {
        console.error('GraphQL errors:', data.errors);
        this.showError('Failed to fetch address suggestions');
        return;
      }

      if (data.data && data.data.predictions) {
        this.displaySuggestions(data.data.predictions, query);
      } else {
        this.hideSuggestions();
      }
    } catch (error) {
      console.error('Error fetching address suggestions:', error);
      this.showError('Error loading address suggestions');
    }
  }

  displaySuggestions(predictions, query) {
    if (!predictions || predictions.length === 0) {
      this.hideSuggestions();
      return;
    }

    // Clear previous suggestions
    this.suggestionsContainer.innerHTML = '';

    // Create suggestion items
    predictions.forEach((prediction) => {
      const suggestionItem = document.createElement('div');
      suggestionItem.className = 'address-autocomplete-suggestion';
      suggestionItem.textContent = prediction.description;
      
      // Highlight matched substrings
      if (prediction.matchedSubstrings && prediction.matchedSubstrings.length > 0) {
        suggestionItem.innerHTML = this.highlightMatches(
          prediction.description,
          prediction.matchedSubstrings
        );
      }

      // Add click handler
      suggestionItem.addEventListener('click', () => {
        this.selectAddress(prediction);
      });

      this.suggestionsContainer.appendChild(suggestionItem);
    });

    // Show suggestions container
    this.suggestionsContainer.classList.add('active');
  }

  highlightMatches(text, matchedSubstrings) {
    // Sort by offset to process from end to start
    const sorted = [...matchedSubstrings].sort((a, b) => b.offset - a.offset);
    let highlighted = text;

    sorted.forEach((match) => {
      const start = match.offset;
      const end = start + match.length;
      const before = highlighted.substring(0, start);
      const matched = highlighted.substring(start, end);
      const after = highlighted.substring(end);
      highlighted = `${before}<strong>${matched}</strong>${after}`;
    });

    return highlighted;
  }

  async selectAddress(prediction) {
    this.selectedAddress = prediction;
    this.input.value = prediction.description;
    this.hideSuggestions();

    // Show loading state while fetching full address details
    this.showAddressLoading();

    // Fetch full address details
    try {
      const addressDetails = await this.fetchAddressDetails(prediction.addressId);
      
      // Validate address after fetching details
      let validationResult = null;
      try {
        validationResult = await this.fetchAddressValidation(addressDetails);
      } catch (validationError) {
        console.error('Error validating address:', validationError);
        // Continue even if validation fails
      }
      
      // Trigger custom event with prediction, address details, and validation result
      const event = new CustomEvent('addressSelected', {
        detail: {
          prediction: prediction,
          addressDetails: addressDetails,
          validation: validationResult
        }
      });
      this.input.dispatchEvent(event);
    } catch (error) {
      console.error('Error fetching address details:', error);
      // Still trigger event with just prediction if address details fetch fails
      const event = new CustomEvent('addressSelected', {
        detail: {
          prediction: prediction,
          addressDetails: null,
          validation: null,
          error: error.message
        }
      });
      this.input.dispatchEvent(event);
    }
  }

  async fetchAddressDetails(addressId) {
    try {
      const queryPayload = {
        operationName: "address",
        query: `
          query address($addressId: String!, $locale: String!, $sessionToken: String!, $adapterOverride: String, $extendedFields: Boolean = false) {
            address(id: $addressId, locale: $locale, sessionToken: $sessionToken, adapterOverride: $adapterOverride, extendedFields: $extendedFields) {
              address1
              address2
              city
              country
              countryCode
              province
              provinceCode
              zip
              latitude
              longitude
            }
          }
        `,
        variables: {
          addressId: addressId,
          locale: this.options.locale,
          sessionToken: this.sessionToken,
          adapterOverride: "google",
          extendedFields: false
        }
      };

      const response = await fetch('https://atlas.shopifysvc.com/graphql', {
        method: 'POST',
        body: JSON.stringify(queryPayload),
        headers: {
          'content-type': 'application/json',
        },
      });

      const data = await response.json();

      if (data.errors) {
        console.error('GraphQL errors:', data.errors);
        throw new Error('Failed to fetch address details');
      }

      if (data.data && data.data.address) {
        return data.data.address;
      } else {
        throw new Error('No address data returned');
      }
    } catch (error) {
      console.error('Error fetching address details:', error);
      throw error;
    }
  }

  async fetchAddressValidation(addressDetails) {
    try {
      // Prepare address input for validation
      const addressInput = {
        address1: addressDetails.address1 || '',
        address2: addressDetails.address2 || '',
        countryCode: addressDetails.countryCode || this.options.countryCode,
        provinceCode: addressDetails.provinceCode || '',
        zip: addressDetails.zip || '',
        city: addressDetails.city || '',
        phone: ''
      };

      const queryPayload = {
        operationName: "validation",
        query: `
          query validation($address: AddressInput!, $locale: String!, $matchingStrategy: MatchingStrategy) {
            validation(address: $address, locale: $locale, matchingStrategy: $matchingStrategy) {
              validationScope
              validationProfile
              locale
              fields {
                name
                value
              }
              concerns {
                fieldNames
                code
                type
                typeLevel
                suggestionIds
                message
              }
              id
              suggestions {
                id
                address1
                streetName
                streetNumber
                address2
                line2
                neighborhood
                city
                zip
                provinceCode
                province
                countryCode
              }
            }
          }
        `,
        variables: {
          address: addressInput,
          locale: this.options.locale
        }
      };

      const response = await fetch('https://atlas.shopifysvc.com/graphql', {
        method: 'POST',
        body: JSON.stringify(queryPayload),
        headers: {
          'content-type': 'application/json',
        },
      });

      const data = await response.json();

      if (data.errors) {
        console.error('GraphQL validation errors:', data.errors);
        throw new Error('Failed to validate address');
      }

      if (data.data && data.data.validation) {
        return data.data.validation;
      } else {
        throw new Error('No validation data returned');
      }
    } catch (error) {
      console.error('Error fetching address validation:', error);
      throw error;
    }
  }

  showAddressLoading() {
    // This can be used to show a loading indicator in the selected address container
    // The actual implementation will be handled by the event listener in the Liquid template
  }

  showLoading() {
    this.suggestionsContainer.innerHTML = '<div class="address-autocomplete-loading">Loading...</div>';
    this.suggestionsContainer.classList.add('active');
  }

  showError(message) {
    this.suggestionsContainer.innerHTML = `<div class="address-autocomplete-error">${message}</div>`;
    this.suggestionsContainer.classList.add('active');
  }

  hideSuggestions() {
    this.suggestionsContainer.classList.remove('active');
  }

  // Public method to get selected address
  getSelectedAddress() {
    return this.selectedAddress;
  }

  // Public method to fetch address details by addressId
  async getAddressDetails(addressId) {
    return await this.fetchAddressDetails(addressId);
  }

  // Public method to update location
  updateLocation(location) {
    this.options.location = location;
  }

  // Public method to update country code
  updateCountryCode(countryCode) {
    this.options.countryCode = countryCode;
  }
}

// Export for use in other scripts
if (typeof window !== 'undefined') {
  window.AddressAutocomplete = AddressAutocomplete;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = AddressAutocomplete;
}


</script>

<script>
  (function() {
    function initAddressAutocomplete() {
      // Check if AddressAutocomplete class is available
      if (typeof AddressAutocomplete === 'undefined') {
        // If not loaded yet, wait a bit and try again
        setTimeout(initAddressAutocomplete, 100);
        return;
      }

      const input = document.getElementById('address-input');
      const suggestionsContainer = document.getElementById('address-suggestions');
      const selectedAddressContainer = document.getElementById('selected-address');
      
      if (!input || !suggestionsContainer) {
        console.error('Address autocomplete elements not found');
        return;
      }

      const selectedDescription = selectedAddressContainer.querySelector('.selected-address-description');
      const selectedId = selectedAddressContainer.querySelector('.selected-address-id');
      const selectedService = selectedAddressContainer.querySelector('.selected-address-service');
      const addressDetailsContainer = document.getElementById('address-details-container');
      const addressLoading = addressDetailsContainer.querySelector('.address-loading');
      const addressPredictionInfo = addressDetailsContainer.querySelector('.address-prediction-info');
      const addressFullDetails = addressDetailsContainer.querySelector('.address-full-details');

      // Initialize autocomplete
      const autocomplete = new AddressAutocomplete(input, suggestionsContainer, {
        countryCode: 'IN',
        locale: 'en-IN',
   
      });

      // Handle address selection
      input.addEventListener('addressSelected', function(e) {
        const { prediction, addressDetails, validation, error } = e.detail;
        
        // Show selected address container
        selectedAddressContainer.style.display = 'block';
        
        // Display prediction info
        selectedDescription.textContent = `Description: ${prediction.description}`;
        selectedId.textContent = `Address ID: ${prediction.addressId}`;
        selectedService.textContent = `Service: ${prediction.completionService}`;
        
        // Show loading state
        addressLoading.style.display = 'block';
        addressPredictionInfo.style.display = 'block';
        addressFullDetails.style.display = 'none';
        
        const addressValidation = selectedAddressContainer.querySelector('.address-validation');
        const validationStatus = document.getElementById('validation-status');
        const validationConcerns = document.getElementById('validation-concerns');
        const validationSuggestions = document.getElementById('validation-suggestions');
        
        // Hide validation initially
        addressValidation.style.display = 'none';
        validationConcerns.style.display = 'none';
        validationSuggestions.style.display = 'none';
        
        // If address details are available, display them
        if (addressDetails) {
          addressLoading.style.display = 'none';
          addressFullDetails.style.display = 'block';
          
          // Populate address fields
          const fields = {
            'address-field-address1': addressDetails.address1 || 'N/A',
            'address-field-address2': addressDetails.address2 || 'N/A',
            'address-field-city': addressDetails.city || 'N/A',
            'address-field-province': addressDetails.province || 'N/A',
            'address-field-province-code': addressDetails.provinceCode || 'N/A',
            'address-field-zip': addressDetails.zip || 'N/A',
            'address-field-country': addressDetails.country || 'N/A',
            'address-field-country-code': addressDetails.countryCode || 'N/A',
            'address-field-latitude': addressDetails.latitude || 'N/A',
            'address-field-longitude': addressDetails.longitude || 'N/A'
          };
          
          Object.keys(fields).forEach(className => {
            const element = addressFullDetails.querySelector('.' + className);
            if (element) {
              element.textContent = fields[className];
            }
          });
          
          // Display validation results if available
          if (validation) {
            addressValidation.style.display = 'block';
            
            // Display validation status
            const hasConcerns = validation.concerns && validation.concerns.length > 0;
            const isValid = !hasConcerns;
            
            if (isValid) {
              validationStatus.innerHTML = '<div class="validation-success"><strong>✓ Address is Valid</strong><p>No validation concerns found.</p></div>';
            } else {
              validationStatus.innerHTML = '<div class="validation-warning"><strong>⚠ Address Validation Issues</strong><p>Please review the concerns below.</p></div>';
            }
            
            // Display validation info
            const validationInfo = document.createElement('div');
            validationInfo.className = 'validation-info';
            validationInfo.innerHTML = `
              <p><strong>Validation Profile:</strong> ${validation.validationProfile || 'N/A'}</p>
              <p><strong>Validation Scope:</strong> ${validation.validationScope ? validation.validationScope.join(', ') : 'N/A'}</p>
              <p><strong>Validation ID:</strong> ${validation.id || 'N/A'}</p>
            `;
            validationStatus.appendChild(validationInfo);
            
            // Display concerns if any
            if (hasConcerns) {
              validationConcerns.style.display = 'block';
              validationConcerns.innerHTML = '<h5>Validation Concerns:</h5>';
              
              validation.concerns.forEach((concern, index) => {
                const concernDiv = document.createElement('div');
                concernDiv.className = 'concern-item';
                concernDiv.innerHTML = `
                  <p><strong>Field(s):</strong> ${concern.fieldNames ? concern.fieldNames.join(', ') : 'N/A'}</p>
                  <p><strong>Code:</strong> ${concern.code || 'N/A'}</p>
                  <p><strong>Type:</strong> ${concern.type || 'N/A'} (${concern.typeLevel || 'N/A'})</p>
                  <p><strong>Message:</strong> ${concern.message || 'No message'}</p>
                `;
                validationConcerns.appendChild(concernDiv);
              });
            }
            
            // Display suggestions if any
            if (validation.suggestions && validation.suggestions.length > 0) {
              validationSuggestions.style.display = 'block';
              validationSuggestions.innerHTML = '<h5>Suggested Addresses:</h5>';
              
              validation.suggestions.forEach((suggestion, index) => {
                const suggestionDiv = document.createElement('div');
                suggestionDiv.className = 'suggestion-item';
                suggestionDiv.innerHTML = `
                  <p><strong>Address 1:</strong> ${suggestion.address1 || 'N/A'}</p>
                  ${suggestion.address2 ? `<p><strong>Address 2:</strong> ${suggestion.address2}</p>` : ''}
                  <p><strong>City:</strong> ${suggestion.city || 'N/A'}</p>
                  <p><strong>ZIP:</strong> ${suggestion.zip || 'N/A'}</p>
                  <p><strong>Province:</strong> ${suggestion.province || 'N/A'} (${suggestion.provinceCode || 'N/A'})</p>
                  <p><strong>Country Code:</strong> ${suggestion.countryCode || 'N/A'}</p>
                `;
                validationSuggestions.appendChild(suggestionDiv);
              });
            }
          }
        } else if (error) {
          addressLoading.style.display = 'none';
          addressFullDetails.innerHTML = `<p class="address-error">Error loading address details: ${error}</p>`;
          addressFullDetails.style.display = 'block';
        }
      });
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initAddressAutocomplete);
    } else {
      initAddressAutocomplete();
    }
  })();
</script>
